# Core JS

### Какие в JS есть типы данных?

7 типов данных:
 - `Object`
 - `string`
 - `number`
 - `boolean`
 - `null`
 - `undefined`
 - `symbol`
 
typeOf:
 - `{}` = `Object`
 - `[]` = `Object`
 - `null` = `Object`
 - `array` = `Object`
 - `new Date` = `Object`
 - `new String/Boolean/Number` = `Object`
 - `alert` = `function`
 - `function` = `function`
 - `true` = `boolean`
 - `"Текст"` = `string`
 - `undefined` = `undefined`

### Что такое замыкание?

Замыкание - это комбинация функции и лексического окружения, в котором эта функция была определена. Особый участок области видимости функции который доступен внутри фукнции, но не доступен из вне

### что такое лексическое окружение? (Lexical Environment)

Lexical Environment - это объект, создаваемый при каждом запуске ф-ции, куда входят все переманные ф-ции

### что такое var vs let/const и чем они отличаются?

var - старый способ обьявления переменной
let - в случае если переменная будет видоизменятся в будущем
const - в случа если переменная не будет изменяться в будущем

### что такое хоистинг (всплытие)?

это механизм в JavaScript в котором переменные и объявления функций передвигаются вверх своей области видимости перед тем, как код будет выполнен.. Получается, что хоститься: 
1. var
2. function name (FE) 
3. no name function (FD) - но обратиться к ним сразу ты не можешь
4.  let & const - но обратиться к ним ты сразу не можешь
5. Class не хостятся
6. Imports (ES modules)

### как в JS происходит приведение типов?

new Number(2) === 2 // false
new Number(2) == 2 // true
{ a: 1 } === { a: 2 } // false
{ a: 1 } == { a: 2 } // false 

### блочный скоуп обьяснить на примере

### какими методами массива можно найти элемент

- find
- findIndex
- indexOf
- filter
- lastIndexOf
- includes
- some 

### как реализуется наследование ес5/es6 (написать) ?



### отличие прототипного наследования от классического?

прототипное наследование создает цепочку прототипов, в то время как классическое наследование основанное на классах создает иерарихию классов

### для чего нужен Object.create?

для создания обьектов

### написать Object.create полифилл

### для чего нужен prototype у конструкторов?

### нарисовать схему цепочки prototype?

### в чем отличие proto vs prototype?

Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.

Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать proto для новых объектов. prototype является свойством объекта Function. Это прототип объектов, построенных этой функцией.

proto - внутреннее свойство объекта, указывающее на его прототип.   __proto__ - указывает на родителя, prototype - есть только у функций, где функции могут быть и констукторами

Сказал что в нем хранится функция конструктор, окружение, методы наследуемые и proto цепочка прототипов)

### методы Function.prototype

### можно ли переопределить контекст после bind

### отличия стрелочных функций от обычных?

У стрелочных функций нету своего контекста 

### promises что это такое?

это объект который хранит свое состояние(panding, onFullFilled, onRejected), текущий результат (если есть) и ф-ции колбэки.
Предоставляет функционал для работы с асинхронным кодом. Если надо асинхронно выполниь код и по завершении что то сделать еще:

```javascript
const myPromise = new Promise((resolve, reject) => {
    // ... do some async code
    resolve(result);
    reject(error);
})
myPromise.then(result => {
    // ... do smth ...
    return new Promise(() => {}); // create new Promise
});
```


- Promise.all(arr) - резолвится когда все промисы из arr выполнены результат - массив результатов каждого промиса
если один выполлнился с ошибкой => результат - ошибка этого промиса и остальные промисы игнорируются
- Promise.race(arr) - резолвится когда резолвится первый промис из массива с его результатом, остальные игнорируются
- Promise.resolve(value) - возвращает успешно выполненный промис с результатом value
- Promise.reject(error) - возвращает не успешно выполненный промис с результатом error

### es6 структуры данных?

### какие es6 фичи знаешь?

 - `let`
 - `const`
 - `arrow function` 
 - `class`
 - `extends`
 - `operator`
 - `'…' (spreat)`
 - `default params` - `function a(b =2) {}`
 - `promise` - `new Promise()`
 - `Template Literals` формат строки ``
 - `дестуктуризация` - `var let { a } = { a: 1, b: 2 }`
 - `Block-Scoped для let & const`
 - `modules`
 - `Map`
 - `Set`

### Какие ES7 

- `Object.values`
- `Object.entries`
- `пропуск аргументов`

### что такое Set/Map

### реализовать кастомный Set/Map в es5/es6 стилях

### async/await в чем разница?

### что такое модуль?

 - `CommonJS` - `node.js`, 
 - `ES6` - browsers (default)
 
 Суть модулей оптимизация рабты с файлами, а так же решения зависимостей. В случае если есть циклическая зависимость, тогда лучше  сделать ещё один компонент для этого. Также выделение по функциональности часть кода

### Дестуктуризация

Разбитие сложной структры на более мелкую

```javascript
let [firstName, lastName] = ["Илья", "Кантор"];

alert(firstName); // Илья
alert(lastName);  // Кантор
```

### Композиция 

Композиция - это когда один объект предоставляет другому свою функциональность (функцию) частично или полностью

```javascript
function compose(f1, f2) {
  return function(value) {
    return f1(f2(value));
  };
}
const addOneTimesTwo = compose(timesTwo, addOne);
```

### Мемоизация 

// TODO: RL: Move to based

"сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.

```javascript
const memoizedAdd = () => {
    let cache = {};
    return (n) => {
        if (n in cache) { return cache[n] }
        const result = n + 10;
        cache[n] = result;
        return result; 
    }
}
```

### Функции обертки (декораторы)

Декораторы (функции обертки) - приём программирования, который позволяет взять существующую функцию и изменить/расширить ее поведение.

### Каррирование

Каррирование - термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей. Используется в bind

```javascript
function mul(a, b) {
    return a * b;
};
var double = mul.bind(null, 2);
```

### Callback функция

фу́нкция обра́тного вы́зова

```javascript
function greeting(name) { 
  alert('Hello ' + name);
}

function processUserInput(callback) {
  const name = prompt('Please enter your name.');
  callback(name);
}

processUserInput(greeting);
```

### IIEF функция

Самовызывающаяся функция 
```javascript
(() => {})()
```

### Функция высшего порядка

Вункция которая принимает другую фукнцию в качестве аргумента

```javascript
function greeting(name) {
  alert('Hello ' + name);
}

function processUserInput(callback) { // <-- функция высшего порядка
  const name = prompt('Please enter your name.');
  callback(name);
}

processUserInput(greeting);
```

### Что такое EventLoop \ Таски \ Микротаски ?

JS - Однопоточный, не блокирующий язык программирования, придумали Event Loop для многопоточности. 

Состоит из callback que, в который по очереди добавляются различные таски. Ждет своего выполнения. Приоритет: Микротакси, потом такси. 

- Микротаски: промисы, Fetch, async function,
- Таски: setIterval, setTimeout. 

FLow такое: call stack (основной поток JS) + Main function -> DOM API -> Callback quee -> RAF -> Render. Таски работают при принципу стэка - выполнилась ушла, RAF - выполняются сразу кучей, но следующая куча попадет в следующий подход. Микротаски - выполняются постоянно пока очередь не станет пустой 

> - https://habr.com/ru/post/264993/
> - [EN] https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=368s
> - [RU] https://www.youtube.com/watch?v=j4_9BZezSUA&t=1743s

### асинхронный и синхронный код ?

Синхронный код выполняется по очереди, в то время как асинхронный код выполняется паралельно

### FE and FD 

No name function нельзя достучатся, в то время как к именнаввые функции можно переписпользовать. Обе функции всплывают

### Делегирование

Всплытие позволяет сделать такую штуку как event delegation. Она позволяет тебе повесить обработчик на родительский элемент. Но работе с родительским элементом его необходимо идентифицировать правильно, т.к. событие может сработать на дочерний элемент. Также можно завершить работу тещего события, с помощью методы Event.stopPropagation()

### Всплытие/перехват/погружение

"есть 3-и основных стадии: 
1. Погружение (capturing) - это когда event идет с самой верхней точки: document > html > body. Пока не дойдет до элемента на котором сработало событие
2. Перехват (target stage) - Эта стадия отвечает за ""захват"" события на самом элементе где он сработал 
3. Всплытие (bubbling) - Противоположное ""погружение"". Т.е. идем от элемента на который сработал обратотчик вверх по ципочке  

По умолчанию идет такое поведение: 1 стадия отключена
Чтобы ещё включить надо addEventListenter третим аргументом передать true, тогда сработает 1 ии 2 стадия, а 3 нет (но не уверен)"

### Браузерные события

Событие делятся на События мыши, События клавиатуры, События элемента, События документа

### SelectorQuery/GetElementBy..

Живая и не живая коллекция. Query - вернет не живую, а это значит… что при обновлении DOM данная коллекция не обновиться автоматически

### this/контекст

"это специальная ""запись"", которая создаётся  вызове функции с помощью new. Она содержит информацию о том, как была вызвана функция, где была вызвана (call stack), с какими параметрами и тд. Одним свойств этой записи является this. this определяется во время вызова функции. Обычно есть 4 ситуации, которые по своему определяют this:

1. вызов с помощью new: var bar = new foo(), тогда this = новый созданный объект
2. вызов как свойство объекта obj.foo(), тогда this = obj
3. вызов с помощью call/apply, тогда this=объекту указанному в аргумете
4. и deafult байндинг this, когда мы просто вызываем функцию foo(), тогда this равен undefined в strict mode, а не strict mode - глобальному объекту           5. Контекст можно потерять!!!

И отдельно стоит упомянуть bind"

### Передача данных по ссылке

примитивные данные передаются по значению, в то время как обьекты по ссылке

### fetch vs ajax

"fetch 
        + use promice
        + you can abort request
        - you can't report progress
        + You can use the Cache API with the request and response objects
    XMLHttpRequest
        - use cb
        + you can abort request
        + can report progress"
        
### Движки какие знаю

V8 (Chromium), JavaScriptCore (Safari), Tamarin (Adobe Flash), Chakra (IE), SpiderMonkey (Firefox)

### Блокирующий скрипт 

Тот скрипт который не даст выполнятся программе д о тех пор пока не будет он не отработает

### DOM API / DOM Events

"1. Можно вешать на dom элементы
2. На разные события click/mouseover/keydown/focus/input/hover
3. События по умолчанию всплывают (тут лекция про event deligation и event bubbling/capturing"

### event handling

onClick, onMousout, onLoad  and e.t.c

### use strict;

this будет чутка другой f() = 'undefined' and f() = 'window', "==" теперь всегда будет "===", Присваивание значения глобальной переменной защищенной от записи, в строгом режиме попытки удалить неудаляемые свойства будут вызывать исключения (delete Object.prototype), { p: 1, p: 2 }, заморозка `arguments`

### Browser rendering pipeline

JS / CSS / Layout / Paint / Composite 

### V8 optimisation killers

1. debugger
2. eval
3. Мутрирование arguments,
4. Switch-case
5. For-in
6. Старайтесь не мутировать массивы. Т.к. JS резервирует памят на размер массива равному 2x. Если размер превышен значит он увеличивается ещё 2 и т.д.  (вот это я где-то читал... но очень давно поэтому не уверен)"

### V8 optimizations

1. Лучше дергать один и тот же метод много раз, он будет быстрее чем много методов разных
2. Обьявить все св-ва в констукторе класса
3. Старайтесь хранить переменные до 31 бита (т.е. простые числа например), т.к. если будет больше 31 бита, V8 будет пытаться преобразоваться его в обьект. "

### memory leaks

- eventListener
- зацикленность элементов
- не удаление не нужных обьектов
- Ссылки на удалённые из DOM элементы
- глобальные перменные

### Apply, call, bind. Для чего используются? В чем отличия?

 - `bind` - прибывает контекст к фукнции и возвращает новую фукнцию (а также можно забандить определенные аргументы)
 - `aplly и call` - вызывают фукнцию с определенный контекстом. Разница только в том, что `call` принимает арументы, а `apply` массивоподобный обьек. Нельзя второй раз bind сделать

### Как создать объект без прототипа? 

```javascript
Object.create({});
```

### Методы: строк и какие аргументы принимает

replace, repeat, indexOf, slice, toLowerCase, toUpperCase, includes, match, search, split, trim, trimLeft, trimRight, toString, endsWith, concat

### Методы: массива и какие аргументы принимают

map, reduce, forEach, indexOf, find, filter, concat, findIndex, includes, join, keys, entries, values, every, pop, push, shift, unshift

### Методы: Обьекта и какие аргументы принимают

create, toString, hasOwnProperty, keys, entries, freeze, defineProperty(ies), assign

### Методы: Function и какие аргументы принимают 

"// toString() 
// call
// bind
// apply "

### Что такое arguments vs …args

это подобный массиву объект, который содержит аргументы, переданные в функцию

### Что значит псевдомассив

массивоподобный объект, у которого есть длина. Основное отличие от обычного массива, что у он наследуется от другого обьекта, а не от Обьекта Array. Как следствие в нем нету методов массива

### lexical scoping

в JavaScript область действия переменной определяется по её расположению в коде (это очевидно лексически), и вложенные функции имеют доступ к переменным, объявленным вовне.

### 1. Function Declaration

именнованные фукнции, т.е. это функция, объявленная в основном потоке кода.

### 2. Function Expression

фукнция которая была записана в перменную, это объявление функции в контексте какого-либо выражения, например присваивания.

### localStorage, Session, Cookie

localStorage - храниться пока не удалит кто-то из JS или руками, Session - сохраняет пока браузер не закроется, Cookie хранятся в зависимости от настроек

### Область видимости

ES3 - function, ES6 - блочный { } , Это такая область в которой была определна переменная. стоит отдельно вспомнить про hoisting и области видимости переменных и функций (name | no name | declaration)

### call stack

Это осоновной поток выполнения JS кода, чтобы можно было понять в какой момент времени какая функция выполняется

### Что такое Node.JS 

Node.js - это  программная платформа, основанная на движке V8. Является кроссплатформенной и позволяет работать JS не только в браузере. Основными фишками Node.js явлется, движок тот же что и использует Chrome. Использует неблокирующую модель ввода-вывода. Также NPM (пакетный менеджер) является самым большим в мире  и насчитает около 900 тыс. библиотек. Основные отличия от работы в браузере: глобальный обьект не window, a global. Есть дополнительные API для работы (работа с файловой сисетомой и http, процессами и т.д.)

### Что такое error first callback 

Это паттерн который в callback фукнцию первым аргументом передает ошиюку, если она была, а если нет `null`

### requestAnimationFrame

"функция которая принимает callback  в которой будем выполнять анимацию
Вызовиться когда браузер готов будет перерисовавыеться, возвращает id. Его можно удалить
Возвращает ID async запроса, по которому его можно потом удалить используя метод cancleAnimationFrame.
callbackFunction принимает  аргумент время в которое будет вызвана фукнция. Сallback функция должна взывать сам requestAnimationFrame, иначе анимация остановится отрисуется за один раз, другими словами чтобы отрисовать несколько кадров"

### monkey patching / что если рашсирять core js прототипы

Обратная совместимость, неочевидное поведение

### Map

has, get, set, entries, values, keys, delete, clear, size

### Set

add, has, clear, delete, entries, keys, values, 

### WeakMap

Может в качестве ключей можно только обьекты

обекты хранятся до тех пор пока на них есть другая ссылка, если ссылка пропадает сборщик муссора их удалит

### WeakSet

Может принимать только обьекты

обекты хранятся до тех пор пока на них есть другая ссылка, если ссылка пропадает сборщик муссора их удалит

### Какие элементы не всплывают
load, unload, abort, error, blur, focus, mouseenter, mouseleave и возможно DOMNodeInsertedIntoDocument, DOMNodeRemovedFromDocument
### Как остановить анимация
clearInterval | сancelAnimationFrame()

### Сколько раз срабатывает requestAnimationFrame 

Старается 60 раз в секунду, то может быть и больше если перед этим зависнет EvenLoop

### Как можно сделать анимацию в js без requestAnimationFrame

requestAnimationFrame() и setInterval(, 1000 \ 60)

### duck typing

Если говорить словами «классического программирования», то «duck typing» – это проверка реализации объектом требуемого интерфейса. Если реализует – ок, используем его. Если нет – значит это что-то другое.

### Рекурсия

рекурсия это ф-ция которая вызывает сама себя
