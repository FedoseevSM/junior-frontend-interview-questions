# Other 

- [OOП](#ООП)
- [MVC](#MVC)
- [Типы Данных](#Типы_Данных)
- [Алгоритмы](#Алгоритмы)
- [Паттерны](#Паттерны)
- [Анти Паттерны](#Анти_Паттерны)
- [CODE QUALITY](#CODE_QUALITY)
- [HTTP](#HTTP)
- [Методологии разработки](#Методологии_разработки)
- [Тесты](#Тесты)
- [CI/CD](#CI/CD)

## ООП 

- `ООП` - Обьективно Ориентированая Программирование - методология программирования основнная на представление программы в виде совокупности обьектов, где каждый из них является экземплятором определенного класса и образуют иерархию наследования.

#### Три Кита ООП

- `Инкапсуляция` - Представляет из себя черный ящик (private\public) который реализует какую-то логику не видную внешне
- `Полиморфизм` - Различные классы могут использовать один и тот же метод. Другими словами - это возможность преопределять фукнцию\св-во\метод родительского класса
- `Наследование` - Св-во системы позволяющее описывать новый класс на основе уже существующего. 

#### Остальное

- `Класс` - это элемент ПО описывающий абстрактный тип данных и его частичную или полностью реализацию.
- `Обьект` - это экзмепляр класса
- `Разница между наследование классов и прототипов` - Прототипное наследование создает цепочку прототипов, а классы создают иерархию наследования

## MVC

- `MVC` - Model, View, Controler. Где Model - отвечает за тип данных, Controller - за работу с этими данными. View - за отображение пользователю

## Типы Данных

- `Списки`
  - `Связанные список`  — одна из базовых структур данных. Ее часто сравнивают с массивом, так как многие другие структуры можно реализовать с помощью либо массива, либо связного списка. У этих двух типов есть преимущества и недостатки. 
    Связный список состоит из группы узлов, которые вместе образуют последовательность. Каждый узел содержит две вещи: фактические данные, которые в нем хранятся (это могут быть данные любого типа) и указатель (или ссылку) на следующий узел в последовательности. Также существуют двусвязные списки: в них у каждого узла есть указатель и на следующий, и на предыдущий элемент в списке.
    Основные операции в связном списке включают добавление, удаление и поиск элемента в списке.
  - `Линейный список` - Линейный список – одна из тех структур данных, которая если не приравнивается, то ассоциируется с динамическими структурами. Он представляет собой упорядоченное множество (возможно пустое), в котором добавление и удаление элементов может происходить в любом месте. Элементы списков чаще всего представляют в виде записей, состоящих из поля-информации и одного или двух полей-ссылок на другие элементы списка. Списки имеют последовательную структуру, т.е. для того чтобы перейти к какому-либо элементу, нужно пройти все элементы, предшествующие искомому. Причем если каждый элемент имеет ссылку только на следующий за ним элемент, то каждый такой проход нужно начинать с «головы» списка. Этот недостаток устраняется либо зацикливанием списка (ссылка последнего элемента указывает на первый) – в этом случае вообще теряются понятия начала и конца списка – либо использованием второй ссылки (на предыдущий элемент), чтобы можно было перемещаться в обе стороны.
    При моделировании списка с помощь массива элементом списка будет запись, состоящая из поля информационной части и поля, хранящего индекс следующего элемента в массиве (аналог ссылки). Для того чтобы смоделировать «кучу» свободной памяти, из которой берется память под новые объекты, можно создаеть список свободных элементов.

- `Стэки`
    Стек — это базовая структура данных, которая позволяет добавлять или удалять элементы только в её начале. Она похожа на стопку книг: если вы хотите взглянуть на книгу в середине стека, сперва придется убрать лежащие сверху.
    Стек организован по принципу LIFO (Last In First Out, «последним пришёл — первым вышел») . Это значит, что последний элемент, который вы добавили в стек, первым выйдет из него.
  В стеках можно выполнять три операции: добавление элемента (push), удаление элемента (pop) и отображение содержимого стека (pip).
- `Очередь`
    Эту структуру можно представить как очередь в продуктовом магазине. Первым обслуживают того, кто пришёл в самом начале — всё как в жизни.
    Очередь устроена по принципу FIFO (First In First Out, «первый пришёл — первый вышел»). Это значит, что удалить элемент можно только после того, как были убраны все ранее добавленные элементы.
    Очередь позволяет выполнять две основных операции: добавлять элементы в конец очереди (enqueue) и удалять первый элемент (dequeue).
- `Множество`
  Множество хранит значения данных без определенного порядка, не повторяя их.
        - данные хранятся без определенного порядка
        - не повторяются
Оно позволяет не только добавлять и удалять элементы: есть ещё несколько важных функций, которые можно применять к двум множествам сразу.

- `Граф`
- `Дерево`
    Дерево – множество, состоящее из элемента, называемого корнем, и конечного (возможно пустого) множества деревьев, называемых поддеревьями данного дерева. Дерево, так же как и список, реализуется прежде всего на динамических структурах, т.е. узел дерева содержит два поля-ссылки – на левое и правое поддерево для двоичного дерева и на брата и старшего сына для дерева общего вида. Дерево уже не является линейной структурой, поэтому представление деревьев на последовательной памяти (файлах) представляет собой определенную проблему. Однако все данные хранятся во внешней памяти в виде файлов, поэтому решение этой проблемы необходимо. Тем не менее, сразу стоит оговориться, что это представление не будет в полной мере реализацией АТД дерева на структуре данных файл, поскольку требуется лишь создать обратимое отображение дерева в файл – никаких операций с файлом-деревом совершаться не будет. Создадим новый тип узла дерева (он станет компонентом файла) – запись информационного поля и поля, хранящего число поддеревьев данного узла. В файл будем последовательно записывать каждый узел так, чтобы поддеревья записывались после своего корня. Обратная операция производится с использованием рекурсии. Читаем из файла узел дерева, создаем его и ссылки на его поддеревья (столько, сколько указано в соответствующем поле). Затем для всех указанных поддеревьев повторяем ту же процедуру.
    Дерево — это структура данных, состоящая из узлов. Ей присущи следующие свойства:
        - Каждое дерево имеет корневой узел (вверху).
        - Корневой узел имеет ноль или более дочерних узлов.
        - Каждый дочерний узел имеет ноль или более дочерних узлов, и так далее.

  - `Двоичное дерево поиска`
    У двоичного дерева поиска есть два дополнительных свойства:
    - Каждый узел имеет до двух дочерних узлов (потомков).
    - Каждый узел меньше своих потомков справа, а его потомки слева меньше его самого.
    Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой операции пропорционально логарифму общего числа элементов в дереве.

  - `Префиксное дерево`
    Префиксное (нагруженное) дерево — это разновидность дерева поиска. Оно хранит данные в метках, каждая из которых представляет собой узел на дереве. Такие структуры часто используют, чтобы хранить слова и выполнять быстрый поиск по ним — например, для функции автозаполнения.
    Каждый узел в языковом префиксном дереве содержит одну букву слова. Чтобы составить слово, нужно следовать по ветвям дерева, проходя по одной букве за раз. Дерево начинает ветвиться, когда порядок букв отличается от других имеющихся в нем слов или когда слово заканчивается. Каждый узел содержит букву (данные) и булево значение, которое указывает, является ли он последним в слове.
    Посмотрите на иллюстрацию и попробуйте составить слова. Всегда начинайте с корневого узла вверху и спускайтесь вниз. Это дерево содержит следующие слова: ball, bat, doll, do, dork, dorm, send, sense.
  - `Куча`
  это специализированная структура данных типа дерево, которая удовлетворяет свойству кучи:если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B).
  - `Двоичная куча`
    Двоичная куча — ещё одна древовидная структура данных. В ней у каждого узла не более двух потомков. Также она является совершенным деревом: это значит, что в ней полностью заняты данными все уровни, а последний заполнен слева направо.
- `Массив`
  Массив — упорядоченный набор данных, используемый для хранения данных одного типа, идентифицируемых с помощью одного или нескольких индексов. В простейшем случае массив имеет постоянную длину и хранит единицы данных одного и того же типа.
  - `Динамический массив`
    Динамическими называются массивы, размер которых может изменяться во время выполнения программы. Обычные (не динамические) массивы называют ещё фиксированными или статическими.
  - `Гетерогенные массивы`
    Гетерогенным называется массив, в разные элементы которого могут быть непосредственно записаны значения, относящиеся к различным типам данных. Массив, хранящий указатели на значения различных типов, не является гетерогенным, так как собственно хранящиеся в массиве данные относятся к единственному типу — типу «указатель». Гетерогенные массивы удобны как универсальная структура для хранения наборов данных произвольных типов. Реализация гетерогенности требует усложнения механизма поддержки массивов в трансляторе языка.
  - `Map (ассоциативный массив и словарь)`
    Map — это структура, которая хранит данные в парах ключ/значение, где каждый ключ уникален. Иногда её также называют ассоциативным массивом или словарём. Map часто используют для быстрого поиска данных. Она позволяет делать следующие вещи:
  - `Хэш-таблицы`
    Хэш-таблица — это похожая на Map структура, которая содержит пары ключ/значение. Она использует хэш-функцию для вычисления индекса в массиве из блоков данных, чтобы найти желаемое значение.
    Обычно хэш-функция принимает строку символов в качестве вводных данных и выводит числовое значение. Для одного и того же ввода хэш-функция должна возвращать одинаковое число. Если два разных ввода хэшируются с одним и тем же итогом, возникает коллизия. Цель в том, чтобы таких случаев было как можно меньше.
    Таким образом, когда вы вводите пару ключ/значение в хэш-таблицу, ключ проходит через хэш-функцию и превращается в число. В дальнейшем это число используется как фактический ключ, который соответствует определенному значению. Когда вы снова введёте тот же ключ, хэш-функция обработает его и вернет такой же числовой результат. Затем этот результат будет использован для поиска связанного значения. Такой подход заметно сокращает среднее время поиска. 
  - `АВЛ - деревья`
    https://habr.com/post/150732/


## Алгоритмы 

### Сложность алгоритмов

`Big O` - время затраченное на выполнение алгоритма относительно его входных данных.
Бывают: `O(n^2)`, `O(N*logn(N))`, `O(2^N)` и т.д.

### Сортировки

- `Пузырьком`
- `Быстрая`
- `Шейкер`
- `Вставками`
- `Прямым выбором`
- `Слиянием`

### Алгоритмы Поиска

- `Последовательный`
- `По ключам`
- `Бинарный`
- `Поиск в глубину`
- `Поиск в ширину`

## Паттерны

#### Порождающие

Порождающие паттерны отвечают за удобно и безопасное создание новых классов\обьектов

- `Одиночка`
- `Строитель`
- `Фабричный метод`
- `Фабрика`

#### Поведенческие

Поведенческие Решают задачи эффективного и безопасного взаимодействия между объектами программы.

- `Наблюдатель`
- `Посредник`

#### Структурные

Структурные паттерны отвечают за построение удобных в поддержке иерархий

- `Фасад`

## Анти Паттерны

- `Monkey Patching` - В программировании возможность подмены методов и значений атрибутов классов программы во время её выполнения
- `Слепая вера` - Когда доверяется всем входным данным функции и не проверяет их корректность
- `Soft Code` - Антоним Hard Code
- `Magic Number` - Необяснимые числа переданные в аргументы функций 
- `Жесткое кодирование` - жесткая привязка к данным
- `Лодочный якорь` - остаются не используемые куски кода, после рефакторинга
- `Создание велосипеда` - создание нового функционала аналог которого уже есть
- `Бездумное комментирование` - комментрирование кода как правило излишне


## CODE QUALITY

- `DRY` - Don't repeat yourself
- `KISS` - Keep It Simple and Stupid
- `YAGNI` - You aren't gonna need it (отказ добавления функциональности, в которой нет непосредственной надобности.)
- `SOLID` - S - Каждый класс выполняет лишь одну задачу, O - программные сущности … должны быть открыты для расширения, но закрыты для модификации., L - Наследующий класс должен дополнять, а не изменять базовый. , I - много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения , D - Зависимость на Абстракциях.

## HTTP

протол Hyper Text Transfer Protocol !!! - используют текст для общения клиента и сервера, протокол высшего порядка (по OSI), (7 уровней)
есть request и response, заголовки могут быть разными, а также коды ошибок, типы HTTP запросов, GET|POST, можно передавать бинарные данные, отличие HTTP от HTTPS

- `Отличие HTTP от HTTPS` - HTTP: открытая передача информация, HTTPS - зашифрованная информация, против атаки "человек по середине". HTTP использует (обычно) 8080 порт, в то время как HTTPS: 443. Для работы с HTTPS нужно получить сертификат. Обмен информации проходит путем рукопожатия и отправки публичного ключа

- `request` & `response`
    1. строка запроса (Request Line)
    2. заголовки (Message Headers)
    3. тело сообщения (Entity Body) – необязательный параметр

```text
GET /html HTTP/1.1
Host: domain.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Request: 1
User-Agent: ...
Accept: ...
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US
Cookie: ...
```

- `Виды запросов`
  POST method содержит информацию  в теле сообщения, в то время как GET запрос передает query в url
    - `PUT` - обновление данных
    - `GET` - получение данных
    - `DELETE` - удаление данных
    - `POST` - создание данных
    
- `OSI`
  Open Systems Interconnection Model. 
    1. Application Layer
    2. Presentation - formats data
    3. Session - local to remote
    4. Tranport: - TCP\ UDP
    5. Network - package trasfer
    6. Data link - IEEE 802, PPP
    7. Physical - bits to signal
    
- `DNS` - Domain Name System. IP format like 192.222.333.444 to name `tut.by`
- `CORS` - механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент.
- `REST & SOAP` - SOAP в основм использует XML, а также строгую типизацию данных, кроме этого передача данных передает по POST запросу. В то время как REST, старается использовать другие методы HTTP для передачи информации и может отправить любые данные и не требует строгой типизации даных. SOAP не ограничивает кол-во методов, в то время как REST стадается придерижваться правила CRUD с использование соответствующих HTTP методов
- `Правило CRUD` - Использование только следующих методов `Create, READE, update, Delete`
- `HTTP Ошибки` ## Status
    - 1xx - Information
    - 2xx - OK
    - 3xx - Перенаправление
    - 4xx - Client Error
    - 5xx - Server Error"
## Методологии разработки

#### Agile
Гибкая методология разработки, которая включает в себя Canban, Scrum and e.t.c. . Agile в первую очередь направлен на коммуникацию и качественный конечный продукт.

- `Манифест`:
  Люди и их взаимодействие, Готовый продукт, Сотрудничесвто с заказчиком, Реакция на изменения
- `Принципы Agile`:
    1. Наш высший приоритет – частые и непрерывных поставки продукта
    2. Изменения на поздних этапах разработки.
    3. Гибкие процессы = является конкурентным преимуществом для заказчика.
    4. Выкатывать релизы каждые несколько недель, чем чаще тем лучше (несколько месяцев)
    5. Представители бизнеса и команда разработки должны работать вместе над проектом.
    6. Успешные проекты строятся мотивированными людьми.
    7. Самый эффективный метод взаимодействия - это личная беседа.
    8. Рабочее программное обеспечение – главная мера прогресса проекта
    9. Постоянный темп из-за гибких процессов.
    10. Постоянное внимание к техническому совершенству и качественной архитектуре способствуют гибкости.
    11. Простота необходима, как искусство максимизации работы, которую не следует делать.
    12. Лучшая архитектура, требования, дизайн создается в самоорганизующихся командах.
    13. Команда постоянно ищет способы стать более эффективной"
- `Scrum` - 
    1.  Scrum относиться к гибким методологиям (Agile)
    2. Srum артефакты:
       - Беклог продукта
       - Беклог спринта
       - Инкремент продукта (функциональность продукта)

   
- `User Story` - то короткая формулировка описывающая что-то, что система должна делать для пользователя глазами пользователя

#### Waterfall
1. Процессы и инструменты, 2. Документация, 3. Жесткие контактные ограничения, 4. Следование плану
## Тесты

Тесты бывают разные, инют, интеграционные, нагрузочные и ещё парочка.
Тесты помогают:
1. Рефакторить код
2. организация и модульность
3. Источник вторичной документации
4. предотвращает дифекты
5. помогает всей команде работать вместе, т.е. чтобы ничего сломали при разработке новых вещей

При написании тестов обычно использует правило трех ААА, `Arrange, Act, Assert`.
Есть 2-е основные методологии: `TDD` и `BDD`. Test-drive-development and behavior-drive-development.
Второе дополняет первое. Основывается на юезр сторях и тесто связан с Agile.

`TDD` - нацелено на какой-то метод\класс\абстрацию
`BDD` - нацелено на фичу, а как она будет реализована дело другое

#### F.I.R.S.T спецификация
F - быстрый
I - Независимый
R - Тест должен возвращать всегда один и тот же результат
S - Не требуется ручная проверка, чтобы проверить, прошел ли тест или нет
T - Должен охватывать каждый сценарий и нацелен на TDD

#### Основные методы:
`Dummy` - тупая болванка - arrange
`Spies` - функция шпион
`Mock` - заглушка над всем обьектом и его методами
`Stub` - заглушка над одним методом
`Data` - тестовые данные

## CI/CD

`CI` - Continuous Integration
Входит:
- получение исходного кода из репозитория;
- сборка проекта;
- выполнение тестов;
- развёртывание готового проекта;
- отправка отчетов.

`CD` - Continuous Delivery - Непрерывная доставка (CD) – это практика автоматизации всего процесса релиза ПО. Ижея заключается в том, чтобы выполнять CI, плюс автоматически готовить и вести релиз к продакшену.

## Оптимизация загрузки сайта

- lazy loading
- cash
- minimize files
- optimazу images 
- попытаться предуагадать поведение пользователя
- шрифты
- иконки 
- и т.д.
